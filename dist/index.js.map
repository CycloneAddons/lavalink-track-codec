{"version":3,"sources":["/home/cycloneaddons/lavalink-track-codec/dist/index.js","../src/DataOutput.ts","../src/encoder.ts","../src/decoder.ts","../src/DataInput.ts"],"names":["Buffer"],"mappings":"AAAA;ACAA,gCAAuB;AAKhB,IAAM,WAAA,YAAN,MAAiB;AAAA,iBACd,OAAA,EAAmB,CAAC,EAAA;AAAA,kBACpB,OAAA,EAAS,EAAA;AAAA,EAEjB,SAAA,CAAU,KAAA,EAAqB;AAC7B,IAAA,MAAM,IAAA,EAAMA,cAAAA,CAAO,KAAA,CAAM,CAAC,CAAA;AAC1B,IAAA,GAAA,CAAI,UAAA,CAAW,KAAK,CAAA;AACpB,IAAA,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA;AAAA,EACrB;AAAA,EAEA,YAAA,CAAa,KAAA,EAAsB;AACjC,IAAA,IAAA,CAAK,SAAA,CAAU,MAAA,EAAQ,EAAA,EAAI,CAAC,CAAA;AAAA,EAC9B;AAAA,EAEA,SAAA,CAAU,KAAA,EAA8B;AACtC,IAAA,MAAM,IAAA,EAAMA,cAAAA,CAAO,KAAA,CAAM,CAAC,CAAA;AAC1B,IAAA,MAAM,SAAA,EAAW,OAAO,MAAA,IAAU,SAAA,EAAW,MAAA,EAAQ,MAAA,CAAO,KAAK,CAAA;AACjE,IAAA,GAAA,CAAI,YAAA,CAAa,MAAA,CAAO,SAAA,GAAY,GAAG,CAAA,EAAG,CAAC,CAAA;AAC3C,IAAA,GAAA,CAAI,YAAA,CAAa,MAAA,CAAO,SAAA,EAAW,WAAW,CAAA,EAAG,CAAC,CAAA;AAClD,IAAA,IAAA,CAAK,UAAA,CAAW,GAAG,CAAA;AAAA,EACrB;AAAA,EAEA,QAAA,CAAS,GAAA,EAAmB;AAC1B,IAAA,MAAM,OAAA,EAASA,cAAAA,CAAO,IAAA,CAAK,GAAA,EAAK,MAAM,CAAA;AACtC,IAAA,GAAA,CAAI,MAAA,CAAO,OAAA,EAAS,KAAA,EAAQ;AAC1B,MAAA,MAAM,IAAI,KAAA,CAAM,sDAAsD,CAAA;AAAA,IACxE;AACA,IAAA,MAAM,OAAA,EAASA,cAAAA,CAAO,KAAA,CAAM,CAAC,CAAA;AAC7B,IAAA,MAAA,CAAO,aAAA,CAAc,MAAA,CAAO,MAAM,CAAA;AAClC,IAAA,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA;AACtB,IAAA,IAAA,CAAK,UAAA,CAAW,MAAM,CAAA;AAAA,EACxB;AAAA,EAEA,iBAAA,CAAkB,GAAA,EAAsC;AACtD,IAAA,GAAA,CAAI,IAAA,GAAO,IAAA,EAAM;AACf,MAAA,IAAA,CAAK,YAAA,CAAa,KAAK,CAAA;AAAA,IACzB,EAAA,KAAO;AACL,MAAA,IAAA,CAAK,YAAA,CAAa,IAAI,CAAA;AACtB,MAAA,IAAA,CAAK,QAAA,CAAS,GAAG,CAAA;AAAA,IACnB;AAAA,EACF;AAAA,EAEQ,UAAA,CAAW,GAAA,EAAmB;AACpC,IAAA,IAAA,CAAK,MAAA,CAAO,IAAA,CAAK,GAAG,CAAA;AACpB,IAAA,IAAA,CAAK,OAAA,GAAU,GAAA,CAAI,MAAA;AAAA,EACrB;AAAA,EAEA,QAAA,CAAA,EAAmB;AACjB,IAAA,OAAOA,cAAAA,CAAO,MAAA,CAAO,IAAA,CAAK,MAAA,EAAQ,IAAA,CAAK,MAAM,CAAA;AAAA,EAC/C;AACF,UAAA;ADTA;AACA;AE5CA,IAAM,qBAAA,EAAuB,CAAA;AAC7B,IAAM,mBAAA,EAAqB,CAAA;AAE3B,SAAS,iBAAA,CAAkB,KAAA,EAAsB;AAC/C,EAAA,MAAM;AAAA,IACJ,MAAA,EAAQ,cAAA;AAAA,IACR,OAAA,EAAS,gBAAA;AAAA,IACT,OAAA,EAAS,CAAA;AAAA,IACT,WAAA,EAAa,EAAA;AAAA,IACb,SAAA,EAAW,KAAA;AAAA,IACX,IAAA,EAAM,IAAA;AAAA,IACN,WAAA,EAAa,IAAA;AAAA,IACb,KAAA,EAAO,IAAA;AAAA,IACP,UAAA;AAAA,IACA,SAAA,EAAW;AAAA,EACb,EAAA,EAAI,KAAA;AAEJ,EAAA,GAAA,CAAI,CAAC,UAAA,EAAY;AACf,IAAA,MAAM,IAAI,KAAA,CAAM,uCAAuC,CAAA;AAAA,EACzD;AAEA,EAAA,MAAM,OAAA,EAAS,IAAI,UAAA,CAAW,CAAA;AAE9B,EAAA,MAAA,CAAO,SAAA,CAAU,kBAAkB,CAAA;AACnC,EAAA,MAAA,CAAO,QAAA,CAAS,KAAK,CAAA;AACrB,EAAA,MAAA,CAAO,QAAA,CAAS,MAAM,CAAA;AACtB,EAAA,MAAA,CAAO,SAAA,CAAU,MAAA,CAAO,MAAM,CAAC,CAAA;AAC/B,EAAA,MAAA,CAAO,QAAA,CAAS,UAAU,CAAA;AAC1B,EAAA,MAAA,CAAO,YAAA,CAAa,QAAQ,CAAA;AAE5B,EAAA,MAAA,CAAO,iBAAA,CAAkB,GAAG,CAAA;AAC5B,EAAA,MAAA,CAAO,iBAAA,CAAkB,UAAU,CAAA;AACnC,EAAA,MAAA,CAAO,iBAAA,CAAkB,IAAI,CAAA;AAC7B,EAAA,MAAA,CAAO,QAAA,CAAS,UAAU,CAAA;AAC1B,EAAA,MAAA,CAAO,SAAA,CAAU,QAAQ,CAAA;AAEzB,EAAA,OAAO,MAAA,CAAO,QAAA,CAAS,CAAA;AACzB;AAEA,SAAS,qBAAA,CAAsB,MAAA,EAAgB,aAAA,EAAe,oBAAA,EAA8B;AAC1F,EAAA,MAAM,OAAA,EAAS,MAAA,CAAO,KAAA,CAAM,CAAC,CAAA;AAC7B,EAAA,MAAM,OAAA,EAAS,MAAA,CAAO,MAAA;AACtB,EAAA,GAAA,CAAI,OAAA,EAAS,UAAA,EAAY;AACvB,IAAA,MAAM,IAAI,KAAA,CAAM,iDAAiD,CAAA;AAAA,EACnE;AACA,EAAA,MAAA,CAAO,YAAA,CAAc,aAAA,GAAgB,GAAA,EAAM,MAAM,CAAA;AACjD,EAAA,OAAO,MAAA,CAAO,MAAA,CAAO,CAAC,MAAA,EAAQ,MAAM,CAAA,EAAG,EAAA,EAAI,MAAM,CAAA;AACnD;AAOO,SAAS,WAAA,CAAY,KAAA,EAAsB;AAChD,EAAA,IAAI;AACF,IAAA,MAAM,YAAA,EAAc,iBAAA,CAAkB,KAAK,CAAA;AAC3C,IAAA,MAAM,QAAA,EAAU,qBAAA,CAAsB,WAAW,CAAA;AACjD,IAAA,OAAO,OAAA,CAAQ,QAAA,CAAS,QAAQ,CAAA;AAAA,EAClC,EAAA,MAAA,CAAS,KAAA,EAAO;AACd,IAAA,MAAM,IAAI,KAAA,CAAM,CAAA,wBAAA,EAA4B,KAAA,CAAgB,OAAO,CAAA,CAAA;AACrE,EAAA;AACF;AFiC6D;AACA;AGnGtC;AHqGsC;AACA;AIjGtC;AAGwB,EAAA;AAAhB,IAAA;AAAiB,EAAA;AAF7B,kBAAA;AAIE,EAAA;AACyB,IAAA;AAC5C,EAAA;AAEuB,EAAA;AACM,IAAA;AAC7B,EAAA;AAEmB,EAAA;AAC+B,IAAA;AACG,IAAA;AACpC,IAAA;AACgC,IAAA;AACjD,EAAA;AAEkB,EAAA;AACmC,IAAA;AACpC,IAAA;AACoC,IAAA;AACpC,IAAA;AACc,IAAA;AAC/B,EAAA;AAEkC,EAAA;AACG,IAAA;AACZ,IAAA;AACH,IAAA;AACtB,EAAA;AACF;AJ+F6D;AACA;AGlIlC;AAOwB;AAC7C,EAAA;AACyC,IAAA;AACzB,MAAA;AAClB,IAAA;AAE2C,IAAA;AAGV,IAAA;AACK,IAAA;AAEP,IAAA;AACK,IAAA;AACqB,MAAA;AACzD,IAAA;AAE4B,IAAA;AACC,IAAA;AACS,IAAA;AACL,IAAA;AACE,IAAA;AACA,IAAA;AACO,IAAA;AACN,IAAA;AACH,IAAA;AACO,IAAA;AAEjC,IAAA;AACL,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACA,MAAA;AACF,IAAA;AACc,EAAA;AACqD,IAAA;AACrE,EAAA;AACF;AHwH6D;AACA;AACA;AACA;AACA;AACA","file":"/home/cycloneaddons/lavalink-track-codec/dist/index.js","sourcesContent":[null,"import { Buffer } from \"buffer\";\n\n/**\n * Class to write binary data with helper methods.\n */\nexport class DataOutput {\n  private chunks: Buffer[] = [];\n  private length = 0;\n\n  writeByte(value: number): void {\n    const buf = Buffer.alloc(1);\n    buf.writeUInt8(value);\n    this.pushBuffer(buf);\n  }\n\n  writeBoolean(value: boolean): void {\n    this.writeByte(value ? 1 : 0);\n  }\n\n  writeLong(value: bigint | number): void {\n    const buf = Buffer.alloc(8);\n    const bigValue = typeof value === \"bigint\" ? value : BigInt(value);\n    buf.writeInt32BE(Number(bigValue >> 32n), 0);\n    buf.writeInt32BE(Number(bigValue & 0xFFFFFFFFn), 4);\n    this.pushBuffer(buf);\n  }\n\n  writeUTF(str: string): void {\n    const strBuf = Buffer.from(str, \"utf8\");\n    if (strBuf.length > 0xffff) {\n      throw new Error(\"String exceeds maximum allowed length (65535 bytes).\");\n    }\n    const lenBuf = Buffer.alloc(2);\n    lenBuf.writeUInt16BE(strBuf.length);\n    this.pushBuffer(lenBuf);\n    this.pushBuffer(strBuf);\n  }\n\n  writeNullableText(str: string | null | undefined): void {\n    if (str == null) {\n      this.writeBoolean(false);\n    } else {\n      this.writeBoolean(true);\n      this.writeUTF(str);\n    }\n  }\n\n  private pushBuffer(buf: Buffer): void {\n    this.chunks.push(buf);\n    this.length += buf.length;\n  }\n\n  toBuffer(): Buffer {\n    return Buffer.concat(this.chunks, this.length);\n  }\n}\n","import { DataOutput } from \"./DataOutput\";\nimport { Track } from \"./types\";\n\nconst TRACK_INFO_VERSIONED = 1;\nconst TRACK_INFO_VERSION = 3;\n\nfunction createTrackBuffer(track: Track): Buffer {\n  const {\n    title = \"Unknown Song\",\n    author = \"Unknown Artist\",\n    length = 0,\n    identifier = \"\",\n    isStream = false,\n    uri = null,\n    artworkUrl = null,\n    isrc = null,\n    sourceName,\n    position = 0,\n  } = track;\n\n  if (!sourceName) {\n    throw new Error(\"Missing required property: sourceName\");\n  }\n\n  const output = new DataOutput();\n\n  output.writeByte(TRACK_INFO_VERSION);\n  output.writeUTF(title);\n  output.writeUTF(author);\n  output.writeLong(BigInt(length));\n  output.writeUTF(identifier);\n  output.writeBoolean(isStream);\n\n  output.writeNullableText(uri);\n  output.writeNullableText(artworkUrl);\n  output.writeNullableText(isrc);\n  output.writeUTF(sourceName);\n  output.writeLong(position);\n\n  return output.toBuffer();\n}\n\nfunction wrapWithMessageHeader(buffer: Buffer, messageFlags = TRACK_INFO_VERSIONED): Buffer {\n  const header = Buffer.alloc(4);\n  const length = buffer.length;\n  if (length > 0x3fffffff) {\n    throw new Error(\"Encoded message exceeds maximum allowed length.\");\n  }\n  header.writeInt32BE((messageFlags << 30) | length);\n  return Buffer.concat([header, buffer], 4 + length);\n}\n\n/**\n * Encodes a track object into a base64-encoded message buffer.\n * @param track Track metadata to encode.\n * @returns base64 encoded string.\n */\nexport function encodeTrack(track: Track): string {\n  try {\n    const trackBuffer = createTrackBuffer(track);\n    const wrapped = wrapWithMessageHeader(trackBuffer);\n    return wrapped.toString(\"base64\");\n  } catch (error) {\n    throw new Error(`Failed to encode track: ${(error as Error).message}`);\n  }\n}\n","import { Buffer } from \"buffer\";\nimport { DataInput } from \"./DataInput\";\nimport { Track } from \"./types\";\n\nconst TRACK_INFO_VERSION = 3;\n\n/**\n * Decodes a base64-encoded track buffer string back into a track object.\n * @param base64 Base64 encoded track string.\n * @returns Decoded track object.\n */\nexport function decodeTrack(base64: string): Track {\n  try {\n    if (!base64 || typeof base64 !== \"string\") {\n      throw new Error(\"Invalid input: base64 string is required.\");\n    }\n\n    const buffer = Buffer.from(base64, \"base64\");\n\n    // Skip 4-byte header (message flags and length)\n    const dataBuffer = buffer.slice(4);\n    const input = new DataInput(dataBuffer);\n\n    const version = input.readByte();\n    if (version !== TRACK_INFO_VERSION) {\n      throw new Error(`Unsupported track version: ${version}`);\n    }\n\n    const title = input.readUTF();\n    const author = input.readUTF();\n    const length = Number(input.readLong());\n    const identifier = input.readUTF();\n    const isStream = input.readBoolean();\n    const uri = input.readNullableText();\n    const artworkUrl = input.readNullableText();\n    const isrc = input.readNullableText();\n    const sourceName = input.readUTF();\n    const position = Number(input.readLong());\n\n    return {\n      title,\n      author,\n      length,\n      identifier,\n      isStream,\n      uri,\n      artworkUrl,\n      isrc,\n      sourceName,\n      position,\n    };\n  } catch (error) {\n    throw new Error(`Failed to decode track: ${(error as Error).message}`);\n  }\n}\n","import { Buffer } from \"buffer\";\n\n/**\n * Class to read binary data with helper methods.\n */\nexport class DataInput {\n  private offset = 0;\n\n  constructor(private readonly buffer: Buffer) {}\n\n  readByte(): number {\n    return this.buffer.readUInt8(this.offset++);\n  }\n\n  readBoolean(): boolean {\n    return this.readByte() !== 0;\n  }\n\n  readLong(): bigint {\n    const high = this.buffer.readInt32BE(this.offset);\n    const low = this.buffer.readInt32BE(this.offset + 4);\n    this.offset += 8;\n    return (BigInt(high) << 32n) | BigInt(low >>> 0);\n  }\n\n  readUTF(): string {\n    const length = this.buffer.readUInt16BE(this.offset);\n    this.offset += 2;\n    const strBuf = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return strBuf.toString(\"utf8\");\n  }\n\n  readNullableText(): string | null {\n    const isPresent = this.readBoolean();\n    if (!isPresent) return null;\n    return this.readUTF();\n  }\n}\n"]}