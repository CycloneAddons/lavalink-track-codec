{"version":3,"sources":["../src/DataOutput.ts","../src/encoder.ts","../src/decoder.ts","../src/DataInput.ts"],"sourcesContent":["import { Buffer } from \"buffer\";\n\n/**\n * Class to write binary data with helper methods.\n */\nexport class DataOutput {\n  private chunks: Buffer[] = [];\n  private length = 0;\n\n  writeByte(value: number): void {\n    const buf = Buffer.alloc(1);\n    buf.writeUInt8(value);\n    this.pushBuffer(buf);\n  }\n\n  writeBoolean(value: boolean): void {\n    this.writeByte(value ? 1 : 0);\n  }\n\n  writeLong(value: bigint | number): void {\n    const buf = Buffer.alloc(8);\n    const bigValue = typeof value === \"bigint\" ? value : BigInt(value);\n    buf.writeInt32BE(Number(bigValue >> 32n), 0);\n    buf.writeInt32BE(Number(bigValue & 0xFFFFFFFFn), 4);\n    this.pushBuffer(buf);\n  }\n\n  writeUTF(str: string): void {\n    const strBuf = Buffer.from(str, \"utf8\");\n    if (strBuf.length > 0xffff) {\n      throw new Error(\"String exceeds maximum allowed length (65535 bytes).\");\n    }\n    const lenBuf = Buffer.alloc(2);\n    lenBuf.writeUInt16BE(strBuf.length);\n    this.pushBuffer(lenBuf);\n    this.pushBuffer(strBuf);\n  }\n\n  writeNullableText(str: string | null | undefined): void {\n    if (str == null) {\n      this.writeBoolean(false);\n    } else {\n      this.writeBoolean(true);\n      this.writeUTF(str);\n    }\n  }\n\n  private pushBuffer(buf: Buffer): void {\n    this.chunks.push(buf);\n    this.length += buf.length;\n  }\n\n  toBuffer(): Buffer {\n    return Buffer.concat(this.chunks, this.length);\n  }\n}\n","import { DataOutput } from \"./DataOutput\";\nimport { Track } from \"./types\";\n\nconst TRACK_INFO_VERSIONED = 1;\nconst TRACK_INFO_VERSION = 3;\n\nfunction createTrackBuffer(track: Track): Buffer {\n  const {\n    title = \"Unknown Song\",\n    author = \"Unknown Artist\",\n    length = 0,\n    identifier = \"\",\n    isStream = false,\n    uri = null,\n    artworkUrl = null,\n    isrc = null,\n    sourceName,\n    position = 0,\n  } = track;\n\n  if (!sourceName) {\n    throw new Error(\"Missing required property: sourceName\");\n  }\n\n  const output = new DataOutput();\n\n  output.writeByte(TRACK_INFO_VERSION);\n  output.writeUTF(title);\n  output.writeUTF(author);\n  output.writeLong(BigInt(length));\n  output.writeUTF(identifier);\n  output.writeBoolean(isStream);\n\n  output.writeNullableText(uri);\n  output.writeNullableText(artworkUrl);\n  output.writeNullableText(isrc);\n  output.writeUTF(sourceName);\n  output.writeLong(position);\n\n  return output.toBuffer();\n}\n\nfunction wrapWithMessageHeader(buffer: Buffer, messageFlags = TRACK_INFO_VERSIONED): Buffer {\n  const header = Buffer.alloc(4);\n  const length = buffer.length;\n  if (length > 0x3fffffff) {\n    throw new Error(\"Encoded message exceeds maximum allowed length.\");\n  }\n  header.writeInt32BE((messageFlags << 30) | length);\n  return Buffer.concat([header, buffer], 4 + length);\n}\n\n/**\n * Encodes a track object into a base64-encoded message buffer.\n * @param track Track metadata to encode.\n * @returns base64 encoded string.\n */\nexport function encodeTrack(track: Track): string {\n  try {\n    const trackBuffer = createTrackBuffer(track);\n    const wrapped = wrapWithMessageHeader(trackBuffer);\n    return wrapped.toString(\"base64\");\n  } catch (error) {\n    throw new Error(`Failed to encode track: ${(error as Error).message}`);\n  }\n}\n","import { Buffer } from \"buffer\";\nimport { DataInput } from \"./DataInput\";\nimport { Track } from \"./types\";\n\nconst TRACK_INFO_VERSION = 3;\n\n/**\n * Decodes a base64-encoded track buffer string back into a track object.\n * @param base64 Base64 encoded track string.\n * @returns Decoded track object.\n */\nexport function decodeTrack(base64: string): Track {\n  try {\n    if (!base64 || typeof base64 !== \"string\") {\n      throw new Error(\"Invalid input: base64 string is required.\");\n    }\n\n    const buffer = Buffer.from(base64, \"base64\");\n\n    // Skip 4-byte header (message flags and length)\n    const dataBuffer = buffer.slice(4);\n    const input = new DataInput(dataBuffer);\n\n    const version = input.readByte();\n    if (version !== TRACK_INFO_VERSION) {\n      throw new Error(`Unsupported track version: ${version}`);\n    }\n\n    const title = input.readUTF();\n    const author = input.readUTF();\n    const length = Number(input.readLong());\n    const identifier = input.readUTF();\n    const isStream = input.readBoolean();\n    const uri = input.readNullableText();\n    const artworkUrl = input.readNullableText();\n    const isrc = input.readNullableText();\n    const sourceName = input.readUTF();\n    const position = Number(input.readLong());\n\n    return {\n      title,\n      author,\n      length,\n      identifier,\n      isStream,\n      uri,\n      artworkUrl,\n      isrc,\n      sourceName,\n      position,\n    };\n  } catch (error) {\n    throw new Error(`Failed to decode track: ${(error as Error).message}`);\n  }\n}\n","import { Buffer } from \"buffer\";\n\n/**\n * Class to read binary data with helper methods.\n */\nexport class DataInput {\n  private offset = 0;\n\n  constructor(private readonly buffer: Buffer) {}\n\n  readByte(): number {\n    return this.buffer.readUInt8(this.offset++);\n  }\n\n  readBoolean(): boolean {\n    return this.readByte() !== 0;\n  }\n\n  readLong(): bigint {\n    const high = this.buffer.readInt32BE(this.offset);\n    const low = this.buffer.readInt32BE(this.offset + 4);\n    this.offset += 8;\n    return (BigInt(high) << 32n) | BigInt(low >>> 0);\n  }\n\n  readUTF(): string {\n    const length = this.buffer.readUInt16BE(this.offset);\n    this.offset += 2;\n    const strBuf = this.buffer.slice(this.offset, this.offset + length);\n    this.offset += length;\n    return strBuf.toString(\"utf8\");\n  }\n\n  readNullableText(): string | null {\n    const isPresent = this.readBoolean();\n    if (!isPresent) return null;\n    return this.readUTF();\n  }\n}\n"],"mappings":"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","names":["Buffer","Buffer","TRACK_INFO_VERSION","Buffer"]}